from fastapi import FastAPI, WebSocket
from fastapi.responses import JSONResponse
from datetime import datetime
from ctypes import *
import numpy as np
import cv2
import os
import json
import asyncio
from threading import Lock
import base64
from ultralytics import YOLO

from MvCameraControl_class import *

app = FastAPI()

model_paths = ["models/model1.pt", "models/model2.pt", "models/model3.pt"]
models = [YOLO(p) for p in model_paths]

cams = []
cams_lock = Lock()
clients = set()
camera_configs = []

def load_camera_config():
    global camera_configs
    with open("CameraConfig.json", "r") as f:
        data = json.load(f)
        camera_configs = data["cameras"]

def decode_model_name(model_bytes):
    return bytes(model_bytes).split(b'\x00')[0].decode(errors='ignore').strip()

def init_all_cameras_from_config():
    global cams
    deviceList = MV_CC_DEVICE_INFO_LIST()
    ret = MvCamera.MV_CC_EnumDevices(MV_GIGE_DEVICE, deviceList)
    if ret != 0 or deviceList.nDeviceNum == 0:
        print("‚ùå Kh√¥ng t√¨m th·∫•y camera")
        return

    print(f"‚úÖ T√¨m th·∫•y {deviceList.nDeviceNum} camera")
    cams.clear()

    for cfg in camera_configs:
        serial_target = cfg["serial"].encode()
        found = False

        for i in range(deviceList.nDeviceNum):
            device_info_ptr = cast(deviceList.pDeviceInfo[i], POINTER(MV_CC_DEVICE_INFO))
            device_info = device_info_ptr.contents
            serial = decode_model_name(device_info.SpecialInfo.stGigEInfo.chSerialNumber).encode()

            if serial == serial_target:
                found = True
                cam = MvCamera()

                if cam.MV_CC_CreateHandle(device_info) != 0:
                    print(f"‚ùå L·ªói t·∫°o handle cho {cfg['name']}")
                    break

                if cam.MV_CC_OpenDevice(MV_ACCESS_Exclusive, 0) != 0:
                    print(f"‚ùå L·ªói m·ªü {cfg['name']}")
                    cam.MV_CC_DestroyHandle()
                    break

                # Set config
                if cfg["trigger_mode"].lower() == "off":
                    cam.MV_CC_SetEnumValue("TriggerMode", MV_TRIGGER_MODE_OFF)
                else:
                    cam.MV_CC_SetEnumValue("TriggerMode", MV_TRIGGER_MODE_ON)

                cam.MV_CC_SetEnumValue("PixelFormat", PixelType_Gvsp_RGB8_Packed)
                cam.MV_CC_SetFloatValue("ExposureTime", cfg["exposure_time"])
                cam.MV_CC_SetFloatValue("Gain", cfg["gain"])

                if cam.MV_CC_StartGrabbing() != 0:
                    print(f"‚ùå Kh√¥ng th·ªÉ b·∫Øt ƒë·∫ßu grabbing {cfg['name']}")
                    cam.MV_CC_CloseDevice()
                    cam.MV_CC_DestroyHandle()
                    break

                cams.append({
                    "cam": cam,
                    "model_index": cfg["model_index"],
                    "name": cfg["name"]
                })

                print(f"‚úÖ ƒê√£ k·∫øt n·ªëi {cfg['name']}")
                break

        if not found:
            print(f"‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y camera serial {cfg['serial']}")

    print(f"\nüì¶ T·ªïng s·ªë camera k·∫øt n·ªëi: {len(cams)}")

@app.on_event("startup")
def startup_event():
    load_camera_config()
    with cams_lock:
        init_all_cameras_from_config()

@app.websocket("/ws/image")
async def websocket_image(websocket: WebSocket):
    await websocket.accept()
    client_info = f"{websocket.client.host}:{websocket.client.port}"
    clients.add(websocket)
    print(f"üü¢ WebSocket client connected: {client_info} (Total: {len(clients)})")

    try:
        while True:
            await asyncio.sleep(1)
    except Exception as e:
        print(f"üî¥ WebSocket client disconnected: {client_info} ({e})")
    finally:
        clients.discard(websocket)
        print(f"üü° Client removed: {client_info} (Remaining: {len(clients)})")


@app.get("/capture")
async def capture_all():
    with cams_lock:
        if not cams:
            return JSONResponse(status_code=500, content={"error": "Kh√¥ng c√≥ camera n√†o ƒëang ho·∫°t ƒë·ªông"})

        results = []
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")

        for idx, cam_info in enumerate(cams):
            cam = cam_info["cam"]
            model_index = cam_info["model_index"]
            cam_name = cam_info["name"]

            stOutFrame = MV_FRAME_OUT()
            memset(byref(stOutFrame), 0, sizeof(stOutFrame))

            ret = cam.MV_CC_GetImageBuffer(stOutFrame, 500)
            if ret == 0 and stOutFrame.pBufAddr:
                try:
                    width = stOutFrame.stFrameInfo.nWidth
                    height = stOutFrame.stFrameInfo.nHeight
                    buf_len = stOutFrame.stFrameInfo.nFrameLen

                    buf_type = (c_ubyte * buf_len)
                    buf = buf_type.from_address(addressof(stOutFrame.pBufAddr.contents))
                    np_img = np.frombuffer(buf, dtype=np.uint8).reshape((height, width, 3))

                    # Encode ·∫£nh sang base64
                    _, buffer = cv2.imencode('.jpg', np_img)
                    base64_img = base64.b64encode(buffer).decode()

                    data = {
                        "camera": cam_name,
                        "image": base64_img
                    }

                    # G·ª≠i ·∫£nh qua WebSocket
                    for ws in list(clients):
                        try:
                            await ws.send_json(data)
                            print(f"üì§ G·ª≠i ·∫£nh t·ª´ {cam_name} ƒë·∫øn {ws.client.host}:{ws.client.port}")
                        except Exception as e:
                            print(f"‚ö†Ô∏è L·ªói g·ª≠i ·∫£nh ƒë·∫øn {ws.client.host}:{ws.client.port} ‚Äî {e}")
                            clients.remove(ws)

                    # L∆∞u ·∫£nh
                    filename = f"{cam_name}_{timestamp}.jpg"
                    cv2.imwrite(filename, np_img)
                    print(f"‚úÖ ·∫¢nh t·ª´ {cam_name} ƒë√£ l∆∞u v√† g·ª≠i WebSocket")

                    results.append(filename)

                except Exception as e:
                    print(f"‚ùå L·ªói x·ª≠ l√Ω ·∫£nh {cam_name}: {e}")
                    results.append(None)
                finally:
                    cam.MV_CC_FreeImageBuffer(stOutFrame)
            else:
                print(f"‚ùå L·ªói l·∫•y buffer {cam_name}: m√£ l·ªói {hex(ret)}")
                results.append(None)

        return JSONResponse(content={"images": results})
if __name__ == "__main__":
    import uvicorn
    uvicorn.run(
        "websocketmyapp:app",
        host="0.0.0.0",
        port=8000,
        reload=True  
    )